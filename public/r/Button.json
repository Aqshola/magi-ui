{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "Button",
  "type": "registry:ui",
  "title": "Button",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "src/components/ui/button.tsx",
      "content": "import * as React from \"react\"\r\nimport { Slot } from \"@radix-ui/react-slot\"\r\nimport { cva, type VariantProps } from \"class-variance-authority\"\r\nimport { cn } from \"@/lib/utils\"\r\nimport workletURL from '@/lib/paint-worklet.js?url'\r\n// import \"@/button-polygon.css\"\r\n\r\nconst buttonVariants = cva(\r\n  \"cursor-pointer uppercase inline-flex items-center justify-center gap-2 whitespace-nowrap text-sm font-semi-bold transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default:\r\n          \"bg-primary text-primary-foreground shadow-xs\",\r\n        destructive:\r\n          \"bg-destructive text-white shadow-xs focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\r\n        outline:\r\n          \"border bg-background shadow-xs dark:bg-input/30\",\r\n        secondary:\r\n          \"bg-secondary text-secondary-foreground shadow-xs\",\r\n        ghost:\r\n          \"text-primary dark:text-accent-foreground\",\r\n        link:\r\n          \"text-primary underline-offset-4\",\r\n      },\r\n      size: {\r\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\r\n        sm: \"h-8 gap-1.5 px-3 has-[>svg]:px-2.5\",\r\n        lg: \"h-10 px-6 has-[>svg]:px-4\",\r\n        icon: \"size-9\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n      size: \"default\",\r\n    },\r\n  }\r\n)\r\n\r\nfunction Button({\r\n  className,\r\n  variant,\r\n  size,\r\n  asChild = false,\r\n  isCustomPolygon = true,\r\n  style,\r\n  ...props\r\n}: React.ComponentProps<\"button\"> &\r\n  VariantProps<typeof buttonVariants> & {\r\n    asChild?: boolean\r\n    isCustomPolygon?: boolean\r\n  }) {\r\n  const Comp = asChild ? Slot : \"button\"\r\n\r\n  if (isCustomPolygon) {\r\n    initButtonPaint()\r\n  }\r\n\r\n  function initButtonPaint() {\r\n    if (\"paintWorklet\" in CSS) {\r\n      (CSS as any).paintWorklet.addModule(workletURL)\r\n    }\r\n  }\r\n\r\n  const borderColors: Record<string, string> = {\r\n    default: \"#EC6F1C\", // orange\r\n    destructive: \"#F30505\", // red\r\n    outline: \"white\",\r\n    secondary: \"\", // e.g. blue, change to your theme\r\n    ghost: \"\", // gray\r\n    link: \"\", // green\r\n  }\r\n\r\n  return (\r\n    <Comp\r\n      data-slot=\"button\"\r\n      className={cn(\r\n        buttonVariants({ variant, size, className }),\r\n        isCustomPolygon && variant!='outline'  && \"custom-polygon-button\",\r\n        isCustomPolygon  && variant=='outline' && \"custom-polygon-button-outline\"\r\n      )}\r\n      style={{\r\n        [\"--polygon-border-color\" as any]: borderColors[variant ?? \"default\"],\r\n        [\"--mode\" as any]: variant != \"outline\" ? \"filled\" : \"outlined\",\r\n        ...style,\r\n      }}\r\n      {...props}\r\n    />\r\n  )\r\n}\r\n\r\nexport { Button, buttonVariants }\r\n",
      "type": "registry:ui"
    },
    {
      "path": "src/lib/paint-worklet.js",
      "content": "/*\r\n * CSS Paint API Worklet for Polygon Borders\r\n *\r\n * This worklet creates custom polygon shapes with borders using the CSS Paint API.\r\n * It's registered as 'polygon-border' and can be used in CSS with paint(polygon-border).\r\n *\r\n * The CSS Paint API allows us to programmatically generate images/graphics\r\n * that can be used as CSS backgrounds, borders, etc.\r\n */\r\nregisterPaint('polygon-border', class {\r\n  /*\r\n   * inputProperties: Defines which CSS custom properties this worklet can read\r\n   * These are the CSS variables that will be passed from the CSS to this worklet\r\n   */\r\n  static get inputProperties() {\r\n    return [\r\n      \"--corner-radius\",\r\n      \"--stroke-weight\",\r\n      \"--paint-color\",\r\n      \"--mode\"\r\n    ];\r\n  }\r\n  paint(ctx, geom, properties, args) {\r\n    // Parse corner radius values\r\n    let radii = properties\r\n      .get(\"--corner-radius\")\r\n      .toString()\r\n      .replace(/px/g, \"\")\r\n      .split(\" \");\r\n\r\n    // Handle different corner radius formats\r\n    if (radii.length === 1) {\r\n      radii = [radii[0], radii[0], radii[0], radii[0]];\r\n    } else if (radii.length === 2) {\r\n      radii = [radii[0], radii[1], radii[0], radii[1]];\r\n    } else if (radii.length === 3) {\r\n      radii = [radii[0], radii[1], radii[2], radii[1]];\r\n    }\r\n\r\n    const inset = parseInt(properties.get(\"--stroke-weight\")) / 2 || 0;\r\n    const radius1 = parseInt(radii[0]) || 0;\r\n    const radius2 = parseInt(radii[1]) || 0;\r\n    const radius3 = parseInt(radii[2]) || 0;\r\n    const radius4 = parseInt(radii[3]) || 0;\r\n\r\n    const points = [\r\n      { x: inset, y: radius1 }, //x0,y0\r\n      { x: radius1, y: inset }, //x1,y1\r\n      { x: geom.width - radius2, y: inset }, //x2,y2\r\n      { x: geom.width - inset, y: radius2 }, //x3,y3\r\n      { x: geom.width - inset, y: geom.height - radius3 }, //x4,y4\r\n      { x: geom.width - radius3, y: geom.height - inset }, //x5,y5\r\n      { x: radius4, y: geom.height - inset }, //x6,y6\r\n      { x: inset, y: geom.height - radius4 } //x7,y7\r\n    ];\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(points[0].x, points[0].y); //x0,y0\r\n    ctx.lineTo(points[1].x, points[1].y);\r\n    ctx.lineTo(points[2].x, points[2].y);\r\n    ctx.lineTo(points[3].x, points[3].y);\r\n    ctx.lineTo(points[4].x, points[4].y);\r\n    ctx.lineTo(points[5].x, points[5].y);\r\n    ctx.lineTo(points[6].x, points[6].y);\r\n    ctx.lineTo(points[7].x, points[7].y);\r\n    ctx.closePath();\r\n\r\n    // For masks, we always fill with white (visible) or black (transparent)\r\n    // The 'filled' argument determines the mode\r\n\r\n    if (properties.get(\"--mode\")==\"filled\") {\r\n      ctx.fillStyle = \"white\"; // White = visible in mask\r\n      ctx.fill();\r\n    } else {\r\n      ctx.strokeStyle = \"white\";\r\n      ctx.lineWidth = 2;\r\n      ctx.stroke();\r\n    }\r\n  }\r\n});\r\n",
      "type": "registry:lib"
    }
  ]
}